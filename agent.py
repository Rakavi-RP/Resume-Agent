"""LangGraph agent for resume job application workflow."""

from typing import TypedDict, Annotated
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages
import operator
from tools import (
    calculate_ats_score,
    generate_cover_letter,
    optimize_resume_bullets,
    generate_interview_questions
)


class AgentState(TypedDict):
    """State for the agent workflow."""
    resume: str
    jd: str
    company_name: str
    ats_score: int
    matched_skills: list
    missing_skills: list
    cover_letter: str
    optimized_bullets: str
    interview_questions: str
    final_output: str


def parse_node(state: AgentState) -> AgentState:
    """Initial node - documents already parsed."""
    print("ðŸ“„ Documents parsed and ready")
    return state


def ats_analysis_node(state: AgentState) -> AgentState:
    """Analyze ATS score and skill matching."""
    print("ðŸ” Analyzing ATS score...")
    
    result = calculate_ats_score(state["resume"], state["jd"])
    
    state["ats_score"] = result["score"]
    state["matched_skills"] = result["matched_skills"]
    state["missing_skills"] = result["missing_skills"]
    
    print(f"âœ… ATS Score: {result['score']}/100")
    return state


def cover_letter_node(state: AgentState) -> AgentState:
    """Generate tailored cover letter."""
    print("âœï¸ Generating cover letter...")
    
    cover_letter = generate_cover_letter(
        state["resume"],
        state["jd"],
        state.get("company_name", "the company")
    )
    
    state["cover_letter"] = cover_letter
    print("âœ… Cover letter generated")
    return state


def resume_optimizer_node(state: AgentState) -> AgentState:
    """Optimize resume bullet points."""
    print("ðŸ“ Optimizing resume bullets...")
    
    bullets = optimize_resume_bullets(state["resume"], state["jd"])
    
    state["optimized_bullets"] = bullets
    print("âœ… Resume bullets optimized")
    return state


def interview_prep_node(state: AgentState) -> AgentState:
    """Generate interview questions."""
    print("ðŸ’¼ Generating interview questions...")
    
    questions = generate_interview_questions(state["jd"], state["resume"])
    
    state["interview_questions"] = questions
    print("âœ… Interview questions generated")
    return state


def compile_output_node(state: AgentState) -> AgentState:
    """Compile final job-ready output."""
    print("ðŸ“¦ Compiling final output...")
    
    output = f"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    JOB APPLICATION PACKAGE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“Š ATS MATCH SCORE: {state['ats_score']}/100

âœ… MATCHED SKILLS:
{chr(10).join(f"  â€¢ {skill}" for skill in state['matched_skills'][:10])}

âŒ SKILLS GAP:
{chr(10).join(f"  â€¢ {skill}" for skill in state['missing_skills'][:10])}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        COVER LETTER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{state['cover_letter']}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                   OPTIMIZED RESUME BULLETS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{state['optimized_bullets']}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    INTERVIEW PREPARATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{state['interview_questions']}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Generated by Resume Job Agent
                    Powered by LangGraph + Gemini
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
    
    state["final_output"] = output
    print("âœ… Job application package ready!")
    return state


def create_agent():
    """Create the LangGraph agent workflow."""
    
    # Create graph
    workflow = StateGraph(AgentState)
    
    # Add nodes
    workflow.add_node("parse", parse_node)
    workflow.add_node("ats_analysis", ats_analysis_node)
    workflow.add_node("generate_cover_letter", cover_letter_node)
    workflow.add_node("resume_optimizer", resume_optimizer_node)
    workflow.add_node("interview_prep", interview_prep_node)
    workflow.add_node("compile_output", compile_output_node)
    
    # Define edges (workflow)
    workflow.set_entry_point("parse")
    workflow.add_edge("parse", "ats_analysis")
    workflow.add_edge("ats_analysis", "generate_cover_letter")
    workflow.add_edge("generate_cover_letter", "resume_optimizer")
    workflow.add_edge("resume_optimizer", "interview_prep")
    workflow.add_edge("interview_prep", "compile_output")
    workflow.add_edge("compile_output", END)
    
    # Compile
    app = workflow.compile()
    return app


def run_agent(resume_text: str, jd_text: str, company_name: str = "the company") -> str:
    """
    Run the complete agent workflow.
    
    Args:
        resume_text: Extracted resume text
        jd_text: Extracted job description text
        company_name: Company name for cover letter
        
    Returns:
        Final compiled output text
    """
    agent = create_agent()
    
    initial_state = {
        "resume": resume_text,
        "jd": jd_text,
        "company_name": company_name,
        "ats_score": 0,
        "matched_skills": [],
        "missing_skills": [],
        "cover_letter": "",
        "optimized_bullets": "",
        "interview_questions": "",
        "final_output": ""
    }
    
    # Run the agent
    final_state = agent.invoke(initial_state)
    
    return final_state["final_output"]
